#!/usr/bin/env python3
"""
NextReel Production Environment Setup Script
============================================

SUMMARY FOR CLAUDE CODE:
This script automates Phase 1 (Steps 1.1-1.3) of the production deployment plan.
It creates a secure production environment configuration file with properly 
generated secrets and validates the setup.

WHAT THIS SCRIPT DOES:
1. Creates .env.production file from .env.example template
2. Generates cryptographically secure secrets for Flask and sessions
3. Prompts for required API keys and database credentials
4. Validates the configuration is production-ready
5. Creates backup of the configuration

HOW TO USE WITH CLAUDE CODE:
1. Save this file as: setup_production_env.py
2. Run: python3 setup_production_env.py
3. Follow the interactive prompts
4. The script will create .env.production with secure values
5. Review the validation output to ensure everything is configured

IMPORTANT: 
- Never commit .env.production to version control
- Keep the backup file (.env.production.backup) secure
- Run this script only once per environment
"""

import os
import sys
import secrets
import string
import shutil
from pathlib import Path
from datetime import datetime
import hashlib
import json

# Color codes for terminal output
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

def print_header(message):
    """Print a formatted header"""
    print(f"\n{Colors.HEADER}{Colors.BOLD}{'='*60}{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}{message}{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}{'='*60}{Colors.ENDC}\n")

def print_success(message):
    """Print success message"""
    print(f"{Colors.GREEN}✓ {message}{Colors.ENDC}")

def print_warning(message):
    """Print warning message"""
    print(f"{Colors.WARNING}⚠ {message}{Colors.ENDC}")

def print_error(message):
    """Print error message"""
    print(f"{Colors.FAIL}✗ {message}{Colors.ENDC}")

def print_info(message):
    """Print info message"""
    print(f"{Colors.CYAN}ℹ {message}{Colors.ENDC}")

def generate_secret_key(length=64, include_special=True):
    """Generate a cryptographically secure secret key"""
    if include_special:
        # Include special characters for maximum entropy
        alphabet = string.ascii_letters + string.digits + "!@#$%^&*()_+-=[]{}|;:,.<>?"
    else:
        # Alphanumeric only (safer for some configurations)
        alphabet = string.ascii_letters + string.digits
    
    return ''.join(secrets.choice(alphabet) for _ in range(length))

def generate_secure_token(length=32):
    """Generate a URL-safe token"""
    return secrets.token_urlsafe(length)

def create_env_production():
    """Create the production environment file from template"""
    
    print_header("STEP 1.1: Creating Production Environment File")
    
    # Check if .env.example exists
    if not Path('.env.example').exists():
        print_error(".env.example not found! Creating a basic template...")
        create_basic_env_example()
    
    # Check if .env.production already exists
    if Path('.env.production').exists():
        response = input(f"{Colors.WARNING}⚠ .env.production already exists. Overwrite? (y/N): {Colors.ENDC}")
        if response.lower() != 'y':
            print_info("Skipping .env.production creation")
            return False
        
        # Backup existing file
        backup_name = f".env.production.backup.{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        shutil.copy('.env.production', backup_name)
        print_success(f"Backed up existing file to {backup_name}")
    
    # Copy template to production
    shutil.copy('.env.example', '.env.production')
    print_success("Created .env.production from .env.example")
    
    # Create a backup
    shutil.copy('.env.production', '.env.production.backup')
    print_success("Created backup at .env.production.backup")
    
    return True

def create_basic_env_example():
    """Create a basic .env.example if it doesn't exist"""
    template = """# NextReel Production Configuration
# Generated by setup script

# Environment
FLASK_ENV=development
FLASK_SECRET_KEY=CHANGE_THIS_IN_PRODUCTION
SESSION_SECRET=CHANGE_THIS_IN_PRODUCTION

# Session Configuration
SESSION_TIMEOUT_MINUTES=30
SESSION_IDLE_TIMEOUT_MINUTES=15
SESSION_ROTATION_INTERVAL=10
MAX_SESSION_DURATION_HOURS=24

# Redis Configuration
SESSION_TYPE=redis
UPSTASH_REDIS_URL=redis://localhost:6379

# MySQL Database Configuration for Movies
DB_HOST=127.0.0.1
DB_USER=root
DB_PASSWORD=
DB_NAME=imdb
DB_PORT=3306

# MySQL Database Configuration for User Accounts
USER_DB_HOST=127.0.0.1
USER_DB_USER=root
USER_DB_PASSWORD=
USER_DB_NAME=UserAccounts
USER_DB_PORT=3306

# Production Database Configuration
PROD_DB_HOST=
PROD_DB_USER=
PROD_DB_PASSWORD=
PROD_DB_NAME=imdb
PROD_DB_PORT=3306

# TMDB API Configuration
TMDB_API_KEY=

# SSL Configuration
SSL_CERT_PATH=
VALIDATE_SSL=false

# Monitoring (Grafana Cloud)
GRAFANA_LOKI_URL=
GRAFANA_LOKI_USER=
GRAFANA_LOKI_KEY=

# Application Version
APP_VERSION=1.0.0
"""
    
    with open('.env.example', 'w') as f:
        f.write(template)
    print_success("Created basic .env.example template")

def update_production_secrets():
    """Update the production environment file with secure secrets"""
    
    print_header("STEP 1.2: Generating Production Secrets")
    
    # Generate secure secrets
    flask_secret = generate_secret_key(64, include_special=False)  # Safer for Flask
    session_secret = generate_secret_key(32, include_special=False)
    
    print_info("Generated secure secrets:")
    print(f"  Flask Secret Key: {flask_secret[:20]}... (truncated)")
    print(f"  Session Secret: {session_secret[:20]}... (truncated)")
    
    # Read the current file
    with open('.env.production', 'r') as f:
        lines = f.readlines()
    
    # Update secrets in the file
    updated_lines = []
    for line in lines:
        if line.startswith('FLASK_SECRET_KEY='):
            updated_lines.append(f'FLASK_SECRET_KEY={flask_secret}\n')
            print_success("Updated FLASK_SECRET_KEY")
        elif line.startswith('SESSION_SECRET='):
            updated_lines.append(f'SESSION_SECRET={session_secret}\n')
            print_success("Updated SESSION_SECRET")
        elif line.startswith('FLASK_ENV='):
            updated_lines.append('FLASK_ENV=production\n')
            print_success("Set FLASK_ENV=production")
        elif line.startswith('VALIDATE_SSL='):
            updated_lines.append('VALIDATE_SSL=true\n')
            print_success("Enabled SSL validation")
        else:
            updated_lines.append(line)
    
    # Write back to file
    with open('.env.production', 'w') as f:
        f.writelines(updated_lines)
    
    # Store secrets hash for validation (never store actual secrets)
    secrets_hash = {
        'flask_secret_hash': hashlib.sha256(flask_secret.encode()).hexdigest()[:16],
        'session_secret_hash': hashlib.sha256(session_secret.encode()).hexdigest()[:16],
        'generated_at': datetime.now().isoformat()
    }
    
    with open('.production_secrets.json', 'w') as f:
        json.dump(secrets_hash, f, indent=2)
    
    print_success("Secrets successfully generated and saved")
    return flask_secret, session_secret

def collect_production_config():
    """Interactively collect production configuration"""
    
    print_header("STEP 1.3: Setting Production Variables")
    
    print_info("Please provide your production configuration values.")
    print_info("Press Enter to skip optional values.\n")
    
    config = {}
    
    # Required configurations
    print(f"{Colors.BOLD}Required Configuration:{Colors.ENDC}")
    
    # TMDB API Key
    tmdb_key = input("TMDB API Key (get from themoviedb.org/settings/api): ").strip()
    if tmdb_key:
        config['TMDB_API_KEY'] = tmdb_key
        print_success("TMDB API Key configured")
    else:
        print_warning("TMDB API Key not set - application won't be able to fetch movie data!")
    
    print()
    
    # Optional configurations
    print(f"{Colors.BOLD}Optional Configuration (can be added later):{Colors.ENDC}")
    
    # Production Database
    print("\nProduction MySQL Database (for movies):")
    prod_db_host = input("  Host (e.g., mysql-xxxx.railway.app): ").strip()
    if prod_db_host:
        config['PROD_DB_HOST'] = prod_db_host
        config['PROD_DB_USER'] = input("  Username: ").strip()
        config['PROD_DB_PASSWORD'] = input("  Password: ").strip()
        config['PROD_DB_NAME'] = input("  Database name [imdb]: ").strip() or 'imdb'
        config['PROD_DB_PORT'] = input("  Port [3306]: ").strip() or '3306'
        print_success("Production database configured")
    
    print("\nUser Accounts Database:")
    user_db_host = input("  Host (leave empty to use same as movies DB): ").strip()
    if user_db_host:
        config['USER_DB_HOST'] = user_db_host
        config['USER_DB_USER'] = input("  Username: ").strip()
        config['USER_DB_PASSWORD'] = input("  Password: ").strip()
        config['USER_DB_NAME'] = input("  Database name [UserAccounts]: ").strip() or 'UserAccounts'
        config['USER_DB_PORT'] = input("  Port [3306]: ").strip() or '3306'
    elif prod_db_host:
        # Use same as production DB
        config['USER_DB_HOST'] = config.get('PROD_DB_HOST', '')
        config['USER_DB_USER'] = config.get('PROD_DB_USER', '')
        config['USER_DB_PASSWORD'] = config.get('PROD_DB_PASSWORD', '')
        config['USER_DB_NAME'] = 'UserAccounts'
        config['USER_DB_PORT'] = config.get('PROD_DB_PORT', '3306')
        print_info("Using same database server for user accounts")
    
    # Redis Configuration
    print("\nRedis Configuration (Upstash recommended):")
    redis_url = input("  Redis URL (e.g., rediss://default:pass@host:6379): ").strip()
    if redis_url:
        config['UPSTASH_REDIS_URL'] = redis_url
        # Parse Redis URL for individual components
        if 'rediss://' in redis_url or 'redis://' in redis_url:
            try:
                from urllib.parse import urlparse
                parsed = urlparse(redis_url)
                config['UPSTASH_REDIS_HOST'] = parsed.hostname
                config['UPSTASH_REDIS_PORT'] = str(parsed.port or 6379)
                config['UPSTASH_REDIS_PASSWORD'] = parsed.password or ''
                print_success("Redis configuration parsed")
            except:
                print_warning("Could not parse Redis URL - set components manually")
    
    # Grafana Configuration
    print("\nGrafana Cloud Configuration (optional):")
    loki_url = input("  Loki URL (e.g., https://logs-prod-xxx.grafana.net): ").strip()
    if loki_url:
        config['GRAFANA_LOKI_URL'] = loki_url
        config['GRAFANA_LOKI_USER'] = input("  Loki User ID: ").strip()
        config['GRAFANA_LOKI_KEY'] = input("  Loki API Key: ").strip()
        print_success("Grafana Loki configured")
    
    # Update the .env.production file
    if config:
        update_env_file(config)
    
    return config

def update_env_file(config):
    """Update .env.production with collected configuration"""
    
    # Read current file
    with open('.env.production', 'r') as f:
        lines = f.readlines()
    
    # Update with new values
    updated_lines = []
    updated_keys = set()
    
    for line in lines:
        # Skip comments and empty lines
        if line.strip().startswith('#') or not line.strip():
            updated_lines.append(line)
            continue
        
        # Check if this line contains a key we want to update
        key_updated = False
        for key, value in config.items():
            if line.startswith(f'{key}='):
                updated_lines.append(f'{key}={value}\n')
                updated_keys.add(key)
                key_updated = True
                break
        
        if not key_updated:
            updated_lines.append(line)
    
    # Add any new keys that weren't in the file
    for key, value in config.items():
        if key not in updated_keys:
            updated_lines.append(f'{key}={value}\n')
    
    # Write back
    with open('.env.production', 'w') as f:
        f.writelines(updated_lines)
    
    print_success(f"Updated {len(config)} configuration values")

def validate_production_config():
    """Validate the production configuration"""
    
    print_header("Validating Production Configuration")
    
    issues = []
    warnings = []
    
    # Read the production env file
    config = {}
    with open('.env.production', 'r') as f:
        for line in f:
            if '=' in line and not line.strip().startswith('#'):
                key, value = line.strip().split('=', 1)
                config[key] = value
    
    # Critical checks
    if config.get('FLASK_ENV') != 'production':
        issues.append("FLASK_ENV is not set to 'production'")
    
    if not config.get('FLASK_SECRET_KEY') or config.get('FLASK_SECRET_KEY') == 'CHANGE_THIS_IN_PRODUCTION':
        issues.append("FLASK_SECRET_KEY is not set or using default value")
    
    if not config.get('TMDB_API_KEY'):
        warnings.append("TMDB_API_KEY is not set - movie data features won't work")
    
    # Database checks
    if not config.get('PROD_DB_HOST') and not config.get('DB_HOST'):
        warnings.append("No production database configured")
    
    if not config.get('UPSTASH_REDIS_URL') and not config.get('REDIS_URL'):
        warnings.append("No Redis configuration found - sessions won't persist")
    
    # SSL checks
    if config.get('VALIDATE_SSL') != 'true':
        warnings.append("SSL validation is not enabled")
    
    # Print results
    if not issues and not warnings:
        print_success("All configuration checks passed!")
        print_success("Your production environment is ready!")
    else:
        if issues:
            print_error(f"Found {len(issues)} critical issue(s):")
            for issue in issues:
                print(f"  {Colors.FAIL}✗ {issue}{Colors.ENDC}")
        
        if warnings:
            print_warning(f"Found {len(warnings)} warning(s):")
            for warning in warnings:
                print(f"  {Colors.WARNING}⚠ {warning}{Colors.ENDC}")
    
    print()
    print_info("Configuration summary:")
    print(f"  Environment: {config.get('FLASK_ENV', 'not set')}")
    print(f"  TMDB API: {'configured' if config.get('TMDB_API_KEY') else 'not configured'}")
    print(f"  Production DB: {'configured' if config.get('PROD_DB_HOST') else 'not configured'}")
    print(f"  Redis: {'configured' if config.get('UPSTASH_REDIS_URL') else 'not configured'}")
    print(f"  SSL Validation: {config.get('VALIDATE_SSL', 'false')}")
    print(f"  Monitoring: {'configured' if config.get('GRAFANA_LOKI_URL') else 'not configured'}")
    
    return len(issues) == 0

def create_gitignore_entries():
    """Ensure production files are in .gitignore"""
    
    gitignore_entries = [
        '.env.production',
        '.env.production.backup*',
        '.production_secrets.json',
        '*.pem',
        '*.crt',
        '*.key'
    ]
    
    # Check if .gitignore exists
    gitignore_path = Path('.gitignore')
    if gitignore_path.exists():
        with open(gitignore_path, 'r') as f:
            current_content = f.read()
    else:
        current_content = ""
    
    # Add missing entries
    entries_added = []
    for entry in gitignore_entries:
        if entry not in current_content:
            entries_added.append(entry)
    
    if entries_added:
        with open(gitignore_path, 'a') as f:
            f.write('\n# Production environment files (added by setup script)\n')
            for entry in entries_added:
                f.write(f'{entry}\n')
        print_success(f"Added {len(entries_added)} entries to .gitignore")

def main():
    """Main setup flow"""
    
    print(f"{Colors.CYAN}{Colors.BOLD}")
    print("╔══════════════════════════════════════════════════════════╗")
    print("║     NextReel Production Environment Setup Script         ║")
    print("║                    Phase 1: Steps 1.1-1.3                ║")
    print("╚══════════════════════════════════════════════════════════╝")
    print(f"{Colors.ENDC}")
    
    try:
        # Step 1.1: Create production environment file
        if create_env_production():
            
            # Step 1.2: Generate and update secrets
            flask_secret, session_secret = update_production_secrets()
            
            # Step 1.3: Collect production configuration
            print()
            response = input(f"{Colors.CYAN}Do you want to configure production services now? (y/N): {Colors.ENDC}")
            if response.lower() == 'y':
                collect_production_config()
        
        # Validate configuration
        print()
        is_valid = validate_production_config()
        
        # Update .gitignore
        create_gitignore_entries()
        
        # Final instructions
        print_header("Setup Complete!")
        
        print(f"{Colors.GREEN}{Colors.BOLD}✅ Production environment setup completed!{Colors.ENDC}\n")
        
        print("Next steps:")
        print("1. Review .env.production and add any missing values")
        print("2. Set up your cloud services (database, Redis, monitoring)")
        print("3. Run validation scripts:")
        print(f"   {Colors.CYAN}FLASK_ENV=production python ssl_validator.py{Colors.ENDC}")
        print(f"   {Colors.CYAN}python cache_security_test.py{Colors.ENDC}")
        print("4. Continue with Phase 2 of the deployment plan")
        
        print()
        print(f"{Colors.WARNING}⚠ IMPORTANT REMINDERS:{Colors.ENDC}")
        print("• Never commit .env.production to version control")
        print("• Keep .env.production.backup in a secure location")
        print("• Rotate secrets regularly in production")
        print("• Test with production config locally before deploying")
        
        if not is_valid:
            print()
            print(f"{Colors.FAIL}⚠ Some configuration issues were found. Please address them before deployment.{Colors.ENDC}")
            sys.exit(1)
        
    except KeyboardInterrupt:
        print(f"\n{Colors.WARNING}Setup interrupted by user{Colors.ENDC}")
        sys.exit(1)
    except Exception as e:
        print(f"\n{Colors.FAIL}Error during setup: {e}{Colors.ENDC}")
        sys.exit(1)

if __name__ == "__main__":
    main()